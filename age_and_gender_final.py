# -*- coding: utf-8 -*-
"""Age_and_Gender_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10zM21ZxbYq0JYRR_uw2Y_wMFd9_FZhJw
"""

def imshow(title = "Image", image = None, size = 6):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

import pandas as pd
import numpy as np

# Load the dataset
data = pd.read_csv("/content/age_gender.csv")

def safe_reshape(pixel_string):
    array = np.array(pixel_string.split(), dtype=np.float32)
    if array.size == 2304:
        return array.reshape(48, 48)
    else:
        return np.zeros((48, 48))
# Directly converting 'pixels' column in the DataFrame
data['pixels'] = data['pixels'].apply(lambda x: safe_reshape(x))
data.head()

import matplotlib.pyplot as plt


def display_samples(sample_rows, sample_cols, min_index, max_index):
    figure, axes = plt.subplots(nrows=sample_rows, ncols=sample_cols, figsize=(sample_cols*3, sample_rows*4))
    axes = axes.flatten()

    for ax in axes:
        random_index = np.random.randint(min_index, max_index)
        sample_image = data['pixels'].iloc[random_index]
        sample_gender = 'Female' if data['gender'].iloc[random_index] else 'Male'
        sample_age = data['age'].iloc[random_index]

        ax.imshow(sample_image, cmap='')
        ax.axis('off')
        ax.set_title(f'Gender: {sample_gender}\nAge: {sample_age}')

    plt.tight_layout()
    plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras import layers, models
from tensorflow.keras.utils import get_file
import cv2
from PIL import Image

# Loading the dataset
dataset = pd.read_csv("age_gender.csv")

# Safe reshape function to handle pixel data
def safe_reshape(pixel_string):
    pixels = np.array(pixel_string.split(), dtype='float32')
    if pixels.size == 2304:  # Ensure the array has 48*48 elements
        return pixels.reshape(48, 48) / 255.0
    else:
        # Return a zero array if the size is incorrect, to avoid errors
        return np.zeros((48, 48))

# Preprocessing pixel data using safe_reshape
def preprocess_pixels(pixel_series):
    return pixel_series.apply(safe_reshape)

# Applying the preprocessing function
dataset['pixels'] = preprocess_pixels(dataset['pixels'])

import numpy as np
import pandas as pd



# Pixels data transformation
X = np.stack(data["pixels"].values)  # This automatically stacks the 48x48 pixel arrays into a single numpy array
X = X.astype('float64')  # Ensuring the datatype is float64 which tensorflow likes

# Age data transformation
age = data['age'].values.astype('float64')  # Direct conversion to numpy array and ensuring type is float64

# Gender data transformation
gender = data['gender'].values.astype('int')  # Assuming gender is binary coded as 0 or 1, direct conversion to numpy array

# Combining age and gender into a single numpy array
labels = np.stack((age, gender), axis=1)
labels = labels[..., np.newaxis]  # Adding a new axis to match the desired shape (23705, 2, 1)

# Confirming shapes and types
print("X shape:", X.shape, "X dtype:", X.dtype)
print("labels_f shape:", labels.shape)


print(len(X))

import tensorflow as tf
from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test=train_test_split(X,labels,test_size=0.2)
#print(len(X_train),len(Y_train),len(X_test),len(Y_test))
print(X_train.shape,Y_train.shape,X_test.shape,Y_test.shape)

# Correcting the structure of Y_train_2 and Y_test_2
Y_train_2 = [Y_train[:, 1].reshape(-1, 1), Y_train[:, 0].reshape(-1, 1)]
Y_test_2 = [Y_test[:, 1].reshape(-1, 1), Y_test[:, 0].reshape(-1, 1)]
# These should now be lists of arrays, each shaped (n_samples, 1), suitable for multi-output models in Keras

from tensorflow.keras.layers import Dropout
from keras.models import Sequential
from tensorflow.keras.layers import Flatten,BatchNormalization
from tensorflow.keras.layers import Dense, MaxPooling2D,Conv2D
from tensorflow.keras.layers import Input,Activation,Add
from tensorflow.keras.models import Model
from tensorflow.keras.regularizers import l2
from tensorflow.keras.optimizers import Adam
from keras import optimizers
import tensorflow as tf

"""import tensorflow as tf

def augment_image(image, label1, label2):
    # Add a channels dimension to the image: from (48, 48) to (48, 48, 1)
    image = tf.expand_dims(image, -1)  # -1 adds the dimension at the end

    # Apply augmentation here
    image = tf.image.random_flip_left_right(image)
    image = tf.image.random_brightness(image, max_delta=0.1)  # Random brightness

    # Ensure the image has the correct shape for model input, if necessary
    image = tf.ensure_shape(image, (48, 48, 1))

    return image, (label1, label2)


# Assuming X_train is your input images and Y_train_2 contains two sets of labels
# Ensure X_train is normalized and all datasets are correctly shaped
X_train_normalized = X_train / 255.0

# Convert to tf.data.Dataset
train_dataset = tf.data.Dataset.from_tensor_slices((X_train_normalized, Y_train_2[0], Y_train_2[1]))

# Apply the augmentation function
train_dataset = train_dataset.map(augment_image)

# Shuffle, batch, and prefetch the dataset for optimal performance
train_dataset = train_dataset.shuffle(buffer_size=1024).batch(32).prefetch(buffer_size=tf.data.AUTOTUNE)"""

from tensorflow.keras.models import Model, Sequential
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Dropout, Activation
from tensorflow.keras.regularizers import l2

def build_sequential_part(input_shape):
    # Sequential part of the model
    model = Sequential()
    model.add(Conv2D(32, kernel_size=(3, 3), padding='same', strides=(1, 1), kernel_regularizer=l2(0.001), input_shape=input_shape))
    model.add(Dropout(0.1))
    model.add(Activation('relu'))

    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Conv2D(64, (3, 3), padding='same', kernel_regularizer=l2(0.001)))
    model.add(Dropout(0.1))
    model.add(Activation('relu'))

    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Conv2D(128, (3, 3), padding='same', kernel_regularizer=l2(0.001)))
    model.add(Dropout(0.1))
    model.add(Activation('relu'))

    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Conv2D(256, (3, 3), padding='same', kernel_regularizer=l2(0.001)))
    model.add(Dropout(0.1))
    model.add(Activation('relu'))

    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Flatten())
    return model

# Since Sequential model does not support multiple outputs, we convert to Functional API for the final steps
def build_model_with_sequential_part(input_shape):
    model_base = build_sequential_part(input_shape)

    # Creating a new input layer and reusing the base model
    inputs = Input(shape=input_shape)
    x = model_base(inputs)

    dense_1 = Dense(64, activation='relu')(x)
    dense_2 = Dense(64, activation='relu')(x)

    drop_1 = Dropout(0.2)(dense_1)
    drop_2 = Dropout(0.2)(dense_2)

    output_1 = Dense(1, activation="sigmoid", name='sex_out')(drop_1)
    output_2 = Dense(1, activation="relu", name='age_out')(drop_2)

    # Creating the final model
    final_model = Model(inputs=inputs, outputs=[output_1, output_2])
    final_model.compile(loss=["binary_crossentropy", "mae"], optimizer="Adam", metrics=["accuracy"])

    return final_model

# Example of building the model
model = build_model_with_sequential_part((48, 48, 1))

from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

# Defining callbacks
callback_list = [
    EarlyStopping(monitor='val_loss', patience=12, verbose=1),  #  To Stop training when 'val_loss' is no longer improves
    ModelCheckpoint('best_model.h5', monitor='val_loss', save_best_only=True, verbose=1)  # Saving the best model based on 'val_loss'
]
history = model.fit(
    X_train, [Y_train_2[0], Y_train_2[1]],
    batch_size=64,
    validation_data=(X_test, [Y_test_2[0], Y_test_2[1]]),
    epochs=100,
    callbacks=callback_list
)

Y_test_2[1]
#Y_test_2[0]

evaluation_results = model.evaluate(X_test, [Y_test_2[0], Y_test_2[1]])
print(evaluation_results)

pred=model.predict(X_test)
#pred[1]
pred[0]

pred_gender, pred_age = model.predict(np.expand_dims(X[1980], axis=0))
pred_age[0][0]

import matplotlib.pyplot as plt
import numpy as np

def test_image(ind, X, model):
    plt.imshow(X[ind], cmap='gray')  # Adding cmap='gray' to correctly display grayscale images
    plt.axis('off')
    plt.show()

    image_test = X[ind]
    # Assuming the model's first output is gender and the second output is age as there in the conv structure in the previous code block
    pred_gender, pred_age = model.predict(np.expand_dims(image_test, axis=0))
    sex_f = ['Female', 'Male']
    # For gender, I am using np.round for getting either 0 or 1
    gender_prediction = int(np.round(pred_gender[0][0]))
    age_prediction = int(np.round(pred_age[0][0]))

    print("Predicted Age:", age_prediction)
    print("Predicted Sex:", sex_f[gender_prediction])

from tensorflow.keras.models import load_model
loaded_model = load_model('best_model.h5')
test_image(11000, X, loaded_model)

from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
from PIL import Image
import cv2

def pred_image(image_path, model):
    # Loading the image
    img = Image.open(image_path).convert("L")  # Converting to grayscale ('L') since my model requires that or else I get a cudnn and tensorflow interaction error

    '''image=cv2.imread(image_path)
    imshow("Face_analysis",image)'''
    # Resizing the image to match the model's expected input size
    img_resized = img.resize((48, 48))

    # Converting the image into an array and scaling the pixel values as usual
    img_array = np.array(img_resized) / 255.0


    if img_array.ndim == 2:
        img_array = np.expand_dims(img_array, axis=-1)


    img_batch = np.expand_dims(img_array, axis=0)

    pred = model.predict(img_batch)


    gender_pred, age_pred = pred




    if (gender_pred[0][0])>=0.5:
      gender_prediction=1
    else:
      gender_prediction=0


    age_prediction = int(np.round(age_pred[0][0]))

    '''print("Predicted Age:", age_prediction)
    print("Predicted Sex:", sex_f[gender_prediction])'''
    return age_prediction,sex_f[gender_prediction]

IMAGE_PATH="/content/Nilesh.jpeg"
image=cv2.imread(IMAGE_PATH)
imshow("Face_analysis",image)
age,gender=pred_image(image_path=IMAGE_PATH, model=loaded_model)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
from pathlib import Path
from PIL import Image
import tensorflow as tf
from tensorflow.keras.preprocessing.image import load_img
from sklearn.model_selection import train_test_split
from tensorflow.keras.initializers import random_uniform, glorot_uniform, constant, identity
from tensorflow.keras.layers import Dropout, Input, Add, Dense, Activation, BatchNormalization, Flatten, Conv2D, MaxPooling2D, GlobalMaxPooling2D
from tensorflow.keras.models import Model, load_model

df1=pd.read_csv("/content/age_gender.csv")
df = pd.DataFrame(df1)
df.tail()

def safe_reshape_2(pixel_data):
    if isinstance(pixel_data, str):
        array = np.array(pixel_data.split(), dtype=np.float32)
    elif isinstance(pixel_data, np.ndarray):
        array = pixel_data  # Assuming it's already the correct type
    else:
        return np.zeros((48, 48))  # Handle unexpected data types

    if array.size == 2304:
        return array.reshape(48, 48)
    else:
        return np.zeros((48, 48))

df['pixels'] = df['pixels'].apply(safe_reshape_2)

X = np.stack(df["pixels"].values)
X = X.astype('float32')
#X=X[:13988]  # Ensure the data type matches your model's expected input

age = data['age'].values.astype('float64')  # Direct conversion to numpy array and ensuring type is float64

# Gender data transformation
gender = data['gender'].values.astype('int')  # Assuming gender is binary coded as 0 or 1, direct conversion to numpy array

# Combining age and gender into a single numpy array
labels = np.stack((age, gender), axis=1)
labels = labels[..., np.newaxis]  # Adding a new axis to match the desired shape (23705, 2, 1)

# Confirming shapes and types
print("X shape:", X.shape, "X dtype:", X.dtype)
print("labels shape:", labels.shape)


print(len(X))
print(len(labels))

import tensorflow as tf
from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test=train_test_split(X,labels,test_size=0.2)
#print(len(X_train),len(Y_train),len(X_test),len(Y_test))
print(X_train.shape,Y_train.shape,X_test.shape,Y_test.shape)
# Correcting the structure of Y_train_2 and Y_test_2
Y_train_2 = [Y_train[:, 1].reshape(-1, 1), Y_train[:, 0].reshape(-1, 1)]
Y_test_2 = [Y_test[:, 1].reshape(-1, 1), Y_test[:, 0].reshape(-1, 1)]
# These should now be lists of arrays, each shaped (n_samples, 1), suitable for multi-output models in Keras
y_gender=Y_train_2[0]
y_age=Y_train_2[1]

inputs = Input((48,48,1))
X_shortcut=inputs
X = Conv2D(64, (3, 3), activation='relu', kernel_initializer = glorot_uniform(seed=0))(inputs)
X = BatchNormalization(axis = 3)(X)
X = MaxPooling2D((3, 3))(X)

X = Conv2D(128, (3, 3), activation='relu')(X)
X = MaxPooling2D((2, 2), strides=(2, 2))(X)

X = Conv2D(256, (3, 3), activation='relu')(X)
X = MaxPooling2D((2, 2))(X)

'''X = Conv2D(512, (3, 3), activation='relu')(X)
X = MaxPooling2D((2, 2))(X)'''

X = Flatten()(X)

dense_1 = Dense(256, activation='relu')(X)
dense_2 = Dense(256, activation='relu' )(dense_1)
dense_3 = Dense(256, activation='relu' )(dense_2)
dense_4 = Dense(256, activation='relu' )(dense_3)
dense_5 = Dense(256, activation='relu')(X)
dense_6 = Dense(256, activation='relu')(dense_5)
dense_7 = Dense(256, activation='relu')(dense_6)
dropout_1 = Dropout(0.3)(dense_4)
dropout_2 = Dropout(0.3)(dense_7)
output_1 = Dense(1,activation='sigmoid', name='gender_output')(dropout_1)
output_2 = Dense(1, activation='relu', name='age_output')(dropout_2)

model= Model(inputs=[inputs], outputs=[output_1,output_2])
model.compile(loss=['binary_crossentropy','mae'], optimizer='adam', metrics=['accuracy'])

model_history = model.fit(x=X_train, y=[y_gender, y_age], batch_size = 10, epochs=15, validation_split= 0.1)
model.save("best_model_2.h5")

from tensorflow.keras.models import load_model
loaded_model_2 = load_model('best_model_2.h5')

IMAGE_PATH="/content/Asmit.jpeg"
image=cv2.imread(IMAGE_PATH)
imshow("Face_analysis",image)
age_2,gender_2=pred_image(image_path=IMAGE_PATH, model=loaded_model_2)
age,gender=pred_image(image_path=IMAGE_PATH, model=loaded_model)

#Getting the ensembled result
sex_f = ['Female', 'Male']
print(f"Predicted age: {(age+age_2)/2}")
print(f"Predicted gender: {sex_f[max(gender,gender_2)]}")